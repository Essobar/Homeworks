### Chain of Responsibility pattern

The chain of responsibility pattern is a design pattern that defines a linked list of handlers, each of which is able to 
process requests. When a request is submitted to the chain, it is passed to the first handler in the list that is able to 
process it.

It is not rare to find a problem where an event generated by an object needs to be handled by another object. The Chain of 
Responsibility pattern can solve this problem. In this pattern we have a source of command objects and a series of processing
objects. The command is passed to the first processing object which can handle this command or send to its successor. This
continues until the command is processed or the end of the chain is reached. In this pattern, the object which sends a command
doesnâ€™t know which object will process the command.

Imagine you have a wending machine which accepts coins. Rather than having a slot for each type of coin, the machine has only
one for all of them. The inserted coin is sent to the appropriate storage place that is determined by the receiver of the 
command. We have a Coin class with two properties: Diameter and Weight. The Coin class is a request (or a command). An 
abstract CoinHandlerBase class with a method SetSuccessor() sets the next processing object and an abstract method 
EvaluateCoin which will be overridden by concrete handlers. For each type of coin we must implement a handler. Each handler 
will work with the diameter and weight of the coin respecting slight differences between fixed values defined by the handler
and the properties of the coins. This helps to fix the problem when a coin has a little bigger/smaller diameter or when a coin
is a little heavier or lighter.

```
class FiftyStotinkiHandler : CoinHandlerBase
{
    public override CoinEvaluationResult EvaluateCoin(Coin coin)
    {
        if (Math.Abs(coin.Weight - 8) < 0.02 && Math.Abs(coin.Diameter - 27.3) < 0.15)
        {
            Console.WriteLine("Captured 50ct");
            return CoinEvaluationResult.Accepted;
        }
        if (_successor != null)
        {
            return _successor.EvaluateCoin(coin);
        }
        return CoinEvaluationResult.Rejected;
    }
}

public class FiveStotinkiHandler : CoinHandlerBase
{

    public override CoinEvaluationResult EvaluateCoin(Coin coin)
    {
        if (Math.Abs(coin.Weight - 3.25) < 0.02 && Math.Abs(coin.Diameter - 18) < 0.1)
        {
            Console.WriteLine("Captured 5ct");
            return CoinEvaluationResult.Accepted;
        }
        if (_successor != null)
        {
            return _successor.EvaluateCoin(coin);
        }
        return CoinEvaluationResult.Rejected;
    }
}

class OneLevHandler : CoinHandlerBase
{
    public override CoinEvaluationResult EvaluateCoin(Coin coin)
    {
        if (Math.Abs(coin.Weight - 9.5) < 0.02 && Math.Abs(coin.Diameter - 22.5) < 0.13)
        {
            Console.WriteLine("Captured 1 lev");
            return CoinEvaluationResult.Accepted;
        }
        if (_successor != null)
        {
            return _successor.EvaluateCoin(coin);
        }
        return CoinEvaluationResult.Rejected;
    }
}
 
public class TenStotinkiHandler : CoinHandlerBase
{
    public override CoinEvaluationResult EvaluateCoin(Coin coin)
    {
        if (Math.Abs(coin.Weight - 6.5) < 0.03 && Math.Abs(coin.Diameter - 24.5) < 0.15)
        {
            Console.WriteLine("Captured 10ct");
            return CoinEvaluationResult.Accepted;
        }
        if (_successor != null)
        {
            return _successor.EvaluateCoin(coin);
        }
        return CoinEvaluationResult.Rejected;
    }
}

class TwentyStotinkiHandler : CoinHandlerBase
{
    public override CoinEvaluationResult EvaluateCoin(Coin coin)
    {
        if (Math.Abs(coin.Weight - 5) < 0.01 && Math.Abs(coin.Diameter - 21.4) < 0.1)
        {
            Console.WriteLine("Captured 20ct");
            return CoinEvaluationResult.Accepted;
        }
        if (_successor != null)
        {
            return _successor.EvaluateCoin(coin);
        }
        return CoinEvaluationResult.Rejected;
    }
}
 
public abstract class CoinHandlerBase
{
    protected CoinHandlerBase _successor;

    public void SetSuccessor(CoinHandlerBase successor)
    {
        _successor = successor;
    }

    public abstract CoinEvaluationResult EvaluateCoin(Coin coin);
}

public class Coin
{
    public float Weight { get; set; }
    public float Diameter { get; set; }
}
 
class Program
{
    static void Main()
    {
        var h5 = new FiveStotinkiHandler();
        var h10 = new TenStotinkiHandler();
        var h20 = new TwentyStotinkiHandler();
        var h50 = new FiftyStotinkiHandler();
        var h100 = new OneLevHandler();
        h5.SetSuccessor(h10);
        h10.SetSuccessor(h20);
        h20.SetSuccessor(h50);
        h50.SetSuccessor(h100);

        var tenStotinki = new Coin { Diameter = 24.49F, Weight = 6.5F };
        var fiftyStotinkin = new Coin { Diameter = 27.31F, Weight = 8.01F };
        var counterfeitLev = new Coin { Diameter = 22.5F, Weight = 9F };

        Console.WriteLine(h5.EvaluateCoin(tenStotinki)); 
        Console.WriteLine(h5.EvaluateCoin(fiftyStotinki));
        Console.WriteLine(h5.EvaluateCoin(counterfeitLev));
    }
}

public enum CoinEvaluationResult
{
    Accepted,
    Rejected
}
```
